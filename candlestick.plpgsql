drop type cst cascade;
create type cst as ( dt timestamp without time zone, open numeric(10,6), close numeric(10,6), high numeric(10,6), low numeric(10,6) );

CREATE FUNCTION candlestick(tbl text, n int, unit text, fromdt timestamp without time zone, todt timestamp without time zone)  RETURNS SETOF cst
AS $$
declare
	higher_tf text;
begin
	select case when unit='minute' then 'hour'
	when unit='hour' then 'day'
	when unit='day' then 'month' 
	when unit='month' then 'year' 
	else ''	end into higher_tf;
	if higher_tf='' then raise exception 'unit must be year, month, day, hour, minute, not %', unit; end if;
	--raise info 'unit: %, higher_tf: %', unit, higher_tf;

	RETURN QUERY execute
	'select distinct dt + mn * interval ''' || n::text || ' ' || unit || ''' as dt, ' 
		|| 'case when count(*) over w=1 then lag(ask,1) over w_1row else first_value(ask) over w end::numeric(10,6) as open,'
		|| ' last_value(ask) over w::numeric(10,6) as close,'
		|| 'case when count(*) over w=1 then max(ask) over w_1row else max(ask) over w end::numeric(10,6) as high,'
		|| 'case when count(*) over w=1 then min(ask) over w_1row else min(ask) over w end::numeric(10,6) as low   from (
	select date_trunc(''' || higher_tf || ''', time) as dt, extract(' || unit || ' from time)::int / ' || n::text || ' as mn,  ask '
	|| ' from ' || tbl || ' where time between ''' || fromdt::text || ''' and ''' || todt::text || ''' order by time) as t'
	|| ' window w as (partition by (dt, mn)), w_1row as ( rows 1 preceding ) order by dt asc;';
end;
$$
LANGUAGE 'plpgsql';

